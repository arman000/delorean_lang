grammar Delorean
  rule line
    f:formula sp? ('#' .*)? <Line>
  end

  rule formula
    sp i:identifier sp? '=?' sp? e:expression <ParameterDefault>
    /
    sp i:identifier sp? '=?' <Parameter>
    /
    sp i:identifier sp? '=' sp? e:expression <Formula>
    /
    n:class_name ':' sp? mod:(m:class_name '::')? p:class_name <SubNode>
    /
    n:class_name ':' <BaseNode>
    /
    'import' sp n:class_name sp v:integer <Import>
  end

  rule class_name
    [A-Z] [a-zA-Z0-9_]*
  end

  rule expression
    op:unary_op sp? e:expression <UnOp>
    /
    'if' 	sp? v:expression sp?
    'then' 	sp? e1:expression sp?
    'else' 	sp? e2:expression <IfElse>
    /
    v:getattr_exp sp? op:binary_op sp? e:expression <BinOp>
    /
    v:getattr_exp sp? '[' sp? args:fn_args sp? ']' <IndexOp>
    /
    getattr_exp
  end

  rule getattr_exp
    v:value ga:(('.' identifier)*) <ExpGetAttr>
  end

  rule list_expr
    '[]' <ListExpr>
    /
    '[' sp? e2:expression sp
        'for' sp i:identifier sp 'in' sp e1:expression sp?
        ifexp:('if' sp e3:expression sp?)?
    ']' <ListComprehension>
    /
    '[' sp? args:fn_args sp? ']' <ListExpr>
  end

  rule hash_expr
    '{}' <HashExpr>
    /
    '{' sp? el:expression sp? ':' sp? er:expression sp
        'for' sp i:identifier sp 'in' sp e1:expression sp?
        ifexp:('if' sp ei:expression sp?)?
    '}' <HashComprehension>
    /
    '{' sp? args:hash_args sp? '}' <HashExpr>
  end

  # NOTE: some operations such as << have side-effects (e.g. on
  # Arrays).  So, be cautious about which opertaions are added.
  rule binary_op
    '+' / '-' / '*' / '/' / '%' / '==' / '!=' / '>=' / '<=' / '>' / '<' / '&&' / '||'
  end

  rule unary_op
    '!' / '-'
  end

  rule value
    number 						/
    string 						/ 
    boolean 						/ 
    nil_val						/
    script_call 					/ 
    fn 							/ 
    model_fn 						/ 
    identifier						/
    list_expr 						/
    hash_expr 						/
    mod:(m:class_name '::')? c:class_name <NodeAsValue> 	/
    '(' sp? e:expression sp? ')' 	 <Expr>
  end

  # built-in functions
  rule fn
    fn:fn_name '(' sp? args:fn_args? sp? ')' <Fn>
  end

  rule fn_args
    arg0:expression args_rest:(sp? ',' sp? args:fn_args?)? <FnArgs>
  end

  rule model_fn
    m:model_name '.' fn:identifier '(' sp? ')' <ModelFn>
    /
    m:model_name '.' fn:identifier '(' sp? args:fn_args sp? ')' <ModelFn>
  end

  rule model_name
    class_name ('::' model_name)?
  end

  rule fn_name
    [A-Z] [A-Z0-9]*
  end

  # script calling
  rule script_call
    '@' mod:(m:class_name '::')? c:class_name '(' sp? al:kw_args sp? ')' <ScriptCallNode>
    /
    '@' i:identifier? '(' sp? al:kw_args sp? ')' <ScriptCall>
  end

  rule hash_args
    e0:expression sp? ':' sp? e1:expression args_rest:(sp? ',' sp? al:hash_args?)? <HashArgs>
  end

  rule kw_args
    k:(i:identifier ':' sp?)? arg0:expression args_rest:(sp? ',' sp? al:kw_args)? <KwArgs>
  end

  rule number
    decimal / integer
  end

  rule decimal
    [0-9]+ '.' [0-9]+ <Literal>
  end

  rule integer
    [0-9]+ <Literal>
  end

  rule identifier
    [a-z] [a-zA-Z0-9_]* <Identifier>
  end

  rule boolean
    'true' <Literal> / 'false' <Literal>
  end

  rule nil_val
    'nil' <Literal>
  end

  rule sp
    [\s]+
  end

  rule string
    '"' ('\"' / !'"' .)* '"' <String>
    /
    "'" [^']* "'" <String>
  end
end
