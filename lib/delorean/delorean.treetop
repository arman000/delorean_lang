grammar Delorean
  rule line
    f:formula sp? ('#' .*)? <Line>
  end

  rule formula
    sp i:identifier sp? '=?' sp? e:expression <ParameterDefault>
    /
    sp i:identifier sp? '=?' <Parameter>
    /
    sp i:identifier sp? '=' sp? e:expression <Formula>
    /
    n:class_name ':' sp? mod:(m:class_name '::')? p:class_name <SubNode>
    /
    n:class_name ':' <BaseNode>
    /
    'import' sp n:class_name sp v:integer <Import>
  end

  rule class_name
    [A-Z] [a-zA-Z0-9_]*
  end

  rule expression
    'ERR(' sp? args:fn_args sp? ')' <ErrorOp>
    /
    op:unary_op sp? e:expression <UnOp>
    /
    'if' 	sp? v:expression sp?
    'then' 	sp? e1:expression sp?
    'else' 	sp? e2:expression <IfElse>
    /
    v:getattr_exp sp? op:binary_op sp? e:expression <BinOp>
    /
    getattr_exp
  end

  rule getattr_exp
    v:value dotted:dotted <GetattrExp>
    /
    value
  end

  rule dotted
    d:dot_exp d_rest:dotted? <Dotted>
  end

  rule dot_exp
    '[' sp? args:fn_args sp? ']' <IndexOp>
    /
    '(' sp? al:kw_args? sp? ')' <NodeCall>
    /
    '.' sp? i:identifier '(' sp? al:kw_args? sp? ')' <Call>
    /
    '.' sp? i:identifier <GetAttr>
  end

  rule list_expr
    '[]' <ListExpr>
    /
    '[' sp? e2:expression sp
        'for' sp i:identifier sp 'in' sp e1:expression sp?
        ifexp:('if' sp e3:expression sp?)?
    ']' <ListComprehension>
    /
    '[' sp? args:fn_args sp? ']' <ListExpr>
  end

  rule set_expr
    '{-}' <SetExpr>
    /
    '{' sp? e2:expression sp
        'for' sp i:identifier sp 'in' sp e1:expression sp?
        ifexp:('if' sp e3:expression sp?)?
    '}' <SetComprehension>
    /
    '{' sp? args:fn_args sp? '}' <SetExpr>
  end

  rule hash_expr
    '{}' <HashExpr>
    /
    '{' sp? el:expression sp? ':' sp? er:expression sp
        'for' sp i:identifier sp 'in' sp e1:expression sp?
        ifexp:('if' sp ei:expression sp?)?
    '}' <HashComprehension>
    /
    '{' sp? args:hash_args sp? '}' <HashExpr>
  end

  # NOTE: some operations such as << have side-effects (e.g. on
  # Arrays).  So, be cautious about which opertaions are added.
  rule binary_op
    '==' / '!=' / '>=' / '<=' / '&&' / '||' /
    '>' / '<' / '+' / '-' / '*' / '/' / '%' / '&' / '^' / '|'
  end

  rule unary_op
    '!' / '-'
  end

  rule value
    number 						/
    string 						/
    boolean 						/
    nil_val						/
    identifier						/
    list_expr 						/
    set_expr 						/
    hash_expr 						/
    mod:(m:class_name '::')? c:class_name <NodeAsValue> /
    '(' sp? e:expression sp? ')' 	 <Expr>
  end

  rule fn_args
    arg0:expression args_rest:(sp? ',' sp? args:fn_args?)? <FnArgs>
  end

  rule hash_args
    e0:expression sp? ':' sp? e1:expression args_rest:(sp? ',' sp? al:hash_args?)? <HashArgs>
  end

  rule kw_args
    k:(i:identifier ':' sp?)? arg0:expression args_rest:(sp? ',' sp? al:kw_args?)? <KwArgs>
  end

  rule number
    decimal / integer
  end

  rule decimal
    [0-9]+ '.' [0-9]+ <Literal>
  end

  rule integer
    [0-9]+ <Literal>
  end

  rule identifier
    [a-z] [a-zA-Z0-9_]* <Identifier>
  end

  rule boolean
    'true' <Literal> / 'false' <Literal>
  end

  rule nil_val
    'nil' <Literal>
  end

  rule sp
    [\s]+
  end

  rule string
    '"' ('\"' / !'"' .)* '"' <DString>
    /
    "'" [^']* "'" <DString>
  end
end
