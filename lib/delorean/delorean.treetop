grammar Delorean
  rule line
    f:formula space? ('#' .*)? <Line>
  end

  rule formula
    i:identifier space? '=' space '?' <Parameter>
    /
    i:identifier space? '=?' space? e:expression <ParameterDefault>
    /
    i:identifier space? '=' space? e:expression <Formula>
    /
    n:node_name ':' space? p:node_name <SubNode>
    /
    n:node_name ':' <BaseNode>
  end

  rule node_name
    [A-Z] [a-zA-Z0-9_]*
  end

  rule expression
    op:unary_op space? e:expression <UnOp>
    /
    'if' space? v:expression space?
    'then' space? e1:expression space?
    'else' space? e2:expression <IfElse>
    /
    v:value space? op:binary_op space? e:expression <BinOp>
    /
    value
  end

  rule binary_op
    '+' / '-' / '*' / '/' / '%' / '==' / '!=' / '>=' / '<=' / '>' / '<' / '&&' / '||'
  end

  rule unary_op
    '!' / '-'
  end

 rule value
    number / string / boolean / fn / model_fn / node_getattr / getattr
    /
    '(' space? e:expression space? ')' <Expr>
  end

  # built-in functions
  rule fn
    fn:fn_name '(' space? ')' <Fn>
    /
    fn:fn_name '(' space? args:fn_args space? ')' <Fn>
  end

  rule fn_args
    arg0:expression args_rest:(space? ',' space? args:fn_args)? <FnArgs>
  end

  rule model_fn
    m:model_name '.' fn:identifier '(' space? ')' <ModelFn>
    /
    m:model_name '.' fn:identifier '(' space? args:fn_args space? ')' <ModelFn>
  end

  rule model_name
    class_name '::' model_name
    /
    class_name
  end

  rule fn_name
    [A-Z] [A-Z0-9]*
  end

  rule class_name
    [A-Z] [a-zA-Z0-9]*
  end

  rule node_getattr
    n:node_name '.' i:identifier <NodeGetAttr>
  end

  rule getattr
    i:identifier '.' ga:getattr <GetAttr>
    /
    identifier
  end

  rule number
    decimal / integer
  end

  rule decimal
    [0-9]* '.' [0-9]+ <Decimal>
  end

  rule integer
    [0-9]+ <Integer>
  end

  rule identifier
    ruby_keyword [a-zA-Z0-9_]+ <Identifier>
    /
    !ruby_keyword [a-z] [a-zA-Z0-9_]* <Identifier>
  end

  rule boolean
    'true' <Boolean> / 'false' <Boolean>
  end

  # FIXME: disallowing all Ruby keywords is pretty bogus.  The
  # translator should simply mangle attr names.

  rule ruby_keyword
    'alias'	/
    'and'	/
    'begin' 	/
    'break'	/
    'case'	/
    'class'	/
    'def'	/
    'do'	/
    'else'	/
    'elsif'	/
    'end'	/
    'ensure'	/
    'false'	/
    'for'	/
    'if'	/
    'in'	/
    'module'	/
    'next'	/
    'nil'	/
    'not'	/
    'or'	/
    'redo'	/
    'rescue'	/
    'retry'	/
    'return'	/
    'self'	/
    'super'	/
    'then'	/
    'true'	/
    'undef'	/
    'unless'	/
    'until'	/
    'when'	/
    'while'	/
    'yield'
  end

  rule string
    '"' ('\"' / !'"' .)* '"' <String>
    /
    "'" [^']* "'" <String>
  end

  rule space
    [\s]+
  end
end
